<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <h3>行为型模式</h3>
    <h5>策略模式</h5>
        <dl>
            <dt>模式指南</dt>
            <dd>重要程度3，难度4</dd>
            <dd>命名：Strategy</dd>
            <dd>将不同算法/策略，分装成一个个类</dd>
            <dd>不同的类通过组合不同的算法类，从而具有不同的行为</dd>
            <dt>使用方法</dt>
            <dd>将不同策略定义不同类</dd>
            <dd>在使用者类定义其行为是其实例化传入的策略类的方法</dd>
            <dd>实例化使用者时，根据使用者需要的功能，传入不同的策略类</dd>
            <dt>使用场景</dt>
            <dd>一个类定义了多种方法，且根据不同条件使用其中之一，使用策略模式</dd>
            <dd>一个系统有许多类，但是他们的区别仅仅是他们的行为</dd>
            <dd>策略比较少，不多于4个</dd>
            <dt>优点</dt>
            <dd>将策略和使用者的对应关系，剥离出使用者类</dd>
            <dd>避免大量的if条件判断，也方便修改策略内容</dd>
        </dl>
    <h5>观察者模式</h5>
        <dl>
            <dt>模式指南</dt>
            <dd>重要程度5，难度3</dd>
            <dd>命名：Observer，EventHandler</dd>
            <dd>检测改变，记录信息</dd>
            <dd>定义对象一对多的依赖关系，当一个对象状态改变，所有依赖对象都得到通知并自动更新</dd>
            <dt>使用方法</dt>
            <dd>Subject：目标或主题，存放观察者目录，增加减少观察者，并且通知观察者</dd>
            <dd>ConcreteSubject:具体目标，目标类的子类，扩展目标逻辑，包含被观测数据，通知方法，</dd>
            <dd>Observer：观察者：一般为接口，抽象观测者，接受数据改变，更新数据</dd>
            <dd>ConcreteObserver: 具体目标的引用对象，保存观察者观察目标的状态，具有更新数据方法，同时具有绑定和解绑目标的方法</dd>
            <dt>使用场景</dt>
            <dd>当抽象模型有两个方面，一个依赖另一个，即可独立封装，使他们各自对立改变和复用</dd>
            <dd>当一个对象改变，同时需要改变其他对象，且不知道有多少对象需要改变。</dd>
            <dd>当一个对象通知其他对象，且不知道其他对象是谁</dd>
            <dt>优点</dt>
            <dd>目标和观察者解耦，支持广播通信，简而言之就是他们不要有任何逻辑关系，但观察者却依赖目标者的内容</dd>
        </dl>
    <h5>命令模式</h5>
    <dl>
        <dt>模式指南</dt>
        <dd>重要程度5，难度2</dd>
        <dd>命名Command</dd>
        <dd>解耦请求者和响应者，集中管理</dd>
        <dd>将一个请求封装为对象，从而使用不同请求对客户参数化</dd>
        <dd>对请求排队或记录请求日志，支持可撤销操作</dd>
        <dt>使用方法</dt>
        <dd>将命令执行对象，命令，使用命令者解耦</dd>
        <dd>Commond 抽象命令类：一般是抽象类或接口，其声明了用于执行请求的execute()方法，这些方法调用请求执行者的相关操作</dd>
        <dd>ConcreteCommand 具体命令类： 抽象命令类子类，实现抽象命令类方法，将接收者对象的动作绑定其中，不同execute方法调用请求执行者不同操作</dd>
        <dd>Invoker 调用者：请求发送者，调用命令者，调用者设计使不同确定接收者，只与命令有关联关系</dd>
        <dd>Receiver 接收者: 接收者接收命令，执行请求实际操作，实现业务处理</dd>
        <dd>程序运行时，将具体命令注入调用者，调用者调用命令对象得到execute方法，间接调用接收者工作</dd>
        <dt>使用场景</dt>
        <dd>只要有发布命令的地方都可以使用命令模式</dd>
        <dd>事件监听回调机制</dd>
        <dd>http请求，封装http请求前的数据处理内容</dd>
    </dl>
    <h5>中介模式</h5>
    <dl>
        <dt>模式指南</dt>
        <dd>重要程度5，难度4</dd>
        <dd>命名Controller,MiddleWare</dd>
        <dd>用一个中介对象封装一系列对象的交互</dd>
        <dd>中介者使个对象不需要直接的互相引用，使其耦合松散，独立改变它们之间交互</dd>
        <dd>代理模式1对1，桥接模式1对多，中介模式1对1</dd>
        <dt>使用方法</dt>
        <dd>Mediator 抽象中介者：定义一个接口，该接口用于与各个同事对象之间的通信</dd>
        <dd>ConcreteMediator 具体中介者：抽象中介者子类，通过协调各个同时对象实现协作行为，维持了各个同事对象的相互间接引用</dd>
        <dd>Colleague 抽象同时类：定义各个同事类共有方法，供子类实现，并且维持对抽象中介类的引用，子类通过该引用与中介者通信</dd>
        <dd>ConcreteColleague: 抽象同事类子类；同事类通过中介类与其他同事类通信，并实行抽象类中定义的同事类方法</dd>
        <dt>适合场景</dt>
        <dd>一组对象定义良好，但是通信方式负责，关系依赖混乱</dd>
        <dd>一个对象引用其他很多对象，并直接与也写对象通信，难以复用该对象</dd>
        <dd>通过一个中间类封装多个类中的行为，又不想太多的子类</dd>
        <dt>优点</dt>
        <dd>简化对象关系，将对象互相关系封装，将各个对象解耦</dd>
        <dd>集中控制，将交互的复杂性转变为，中介者的复杂性</dd>
        <dd>减少各同事类的设计与实现</dd>
        <dt>相关模式</dt>
        <dd>同事对象可使用观察者模式与中介者通信</dd>
    </dl>
    <h5>状态模式</h5>
    <dl>
        <dt>模式说明</dt>
        <dd>重要程度5，难度3</dd>
        <dd>命名：State</dd>
        <dd>允许一个对象在其内部状态改变时，改变他的行为，对象看起来修改了类</dd>
        <dd>对象的行为依赖他的状态属性，根据状态改变而改变他的行为</dd>
        <dt>使用模式</dt>
        <dd>将各种具体的状态类抽象</dd>
        <dd>Context 环境类：上下文类，拥有多种状态，维护一个抽象状态类的子类的实例，该实例定义当前状态，</dd>
        <dd>State 抽象状态类：定义一个接口，封装与环境类的一个特定状态相关的行为，声明各种不同状态的对应方法</dd>
        <dd>ConcreateState:具体状态类，抽象状态子类，每个子类实现一个与环境类的一个状态相关的行为，每一个状态类对应环境的一个具体状态，不同具体状态行为不同</dd>

        <dt>使用场景</dt>
        <dd>代码中有大量与对象状态相关的条件语句</dd>
        <dd>promise</dd>
    </dl>
</body>
</html>