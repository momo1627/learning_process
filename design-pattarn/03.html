<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <h3>day3</h3>
    <h5>迭代器模式</h5>
    <dl>
        <dt>模式说明</dt>
        <dd>提供一种方法顺序访问一个聚合对象中各个元素，但不暴露该对象内部的表示</dd>
        <dd>命名Itertator</dd>
        <dd>定义一个接口next()，由接口访问对象所有元素</dd>
        <dt>使用方法</dt>
        <dd>Iterator 抽象迭代器：定义了访问对象元素，遍历对象元素的方法</dd>
        <dd>ConcreteIterator 具体迭代器： 实现抽象迭代器接口；同时定义游标接口，记录迭代器位置</dd>
        <dd>Aggregate 抽象聚合类：管理元素对象，定义创建元素相关迭代器方法，充当一个工厂</dd>
        <dd>ConcreteAggregate: 具体聚合类；返回具体迭代器和具体聚合类的实例</dd>
        <dt>使用场景</dt>
        <dd>访问一个聚合对象内部全部内容，却不调用任何内部接口，只掉用next</dd>
        <dd>提供多种遍历方式，即多种next方法</dd>
        <dt>优点</dt>
        <dd>提供不同便利方式，简化聚合类</dd>
        <dd>在抽象迭代器工厂里，迭代器和聚合类分离，方便扩展</dd>
    </dl>
    <h4>结构模型</h4>
    <p>结构模型考虑如何组合类，构成更大的的结构</p>
    <h5>适配器Adapter</h5>
    <dl>
        <dt>模式说明</dt>
        <dd>重要程度4，难度3</dd>
        <dd>命名Adapter,Wraper</dd>
        <dd>转化一个接口的，使其与其他类兼容，一起工作</dd>
        <dt>使用方法</dt>
        <dd>Target 目标抽象类：定义客户所需接口，可以实抽象类，类，接口</dd>
        <dd>Adapter 适配器类： 适配器模式核心，通过继承target，并关联一个adaptee，实现两者联系</dd>
        <dd>Adaptee 适配者：定义一个已存在接口，它在适配类中根据目标类被改造</dd>
        <dd>适配器模式有类模式和对象模式两种</dd>
        <dt>场景</dt>
        <dd>有需求的改变一个已正常运行系统的接口</dd>
        <dt>优点</dt>
        <dd>让没有关联的类一起运行，提高类的复用，灵活</dd>
        <dt>缺点</dt>
        <dd>过多使用会让系统非常零乱</dd>
    </dl>
    <h5>外观模式 Facade</h5>
    <dl>
        <dt>模式说明</dt>
        <dd>重要程度5，难度1</dd>
        <dd>命名xxx</dd>
        <dd>系统提供一个接口，该接口提供外界对系统内所有子系统的使用</dd>
        <dt>使用方法</dt>
        <dd>在系统内添加一层，该层封装系统内所有接口，整理所有接口，统一暴露API</dd>
        <dd>Facade 外观角色：系统对外接口，将外界调成传给对应的子系统处理</dd>
        <dd>SubSystem 子系统角色：系统内处理外界请求的类或集合，和外观类独立，也视其为客户端</dd>
    </dl>
    <h5>代理模式</h5>
    <dl>
        <dt>模式说明</dt>
        <dd>重要程度4，难度1</dd>
        <dd>命名Proxy</dd>
        <dd>为其他对象提供一种代理，来控制对这个对象的访问</dd>
        <dd>避免直接访问对象，增加中间层，对于接口进行隐藏，用于封装复杂类</dd>
        <dt>实现方法</dt>
        <dd>Subject 抽象目标角色：声明了真实目标和代理的共同接口；使用共同接口的地方，都可以使用代理而不是真是目标</dd>
        <dd>RealSubject 真实主题角色: 定义了代理角色所代表的真实主题，在真实主题里实现业务，客户通过代理调用真实主题的API进行操作</dd>
        <dd>Proxy 代理角色：包含对真实主题的引用，可以操作真实主题对象；并且控制真实主题的引用，在需要的时候创建或删除真是对题对象</dd>
        <dd>通常客户调用代理主题时，还需要进行其他操作，不仅仅是单纯调用真实主题</dd>
    </dl>
    <h5>装饰模式</h5>
    <dl>
        <dt>模式说明</dt>
        <dd>重要程度5，难度1</dd>
        <dd>命名xxxDecorator，xxx具体实现</dd>
        <dd>在现有类或对象的基础上，添加一些功能，但又不会改变其结构，对现有类进行包装</dd>
        <dd>增加功能来说，装饰者模式比子类更好</dd>
        <dt>使用场景</dt>
        <dd>在不想增加子类的情况下，扩展类</dd>
        <dt>实现方法</dt>
        <dd>Component 抽象构件：具体构建和抽象装饰类的共同父类，声明具体构建中的业务方法的基础功能，</dd>
        <dd>ConcreteComponent 具体构件：抽象构件的子类，定义具体的构件对象，实现抽象构件中的声明方法，允许装饰器给他增加功能</dd>
        <dd>Decorator 抽象装饰类：也是抽象构件的子类，用于给具体构件增加方法；具体职责在子类实现，引用抽象构件，</dd>
        <dd>ConcreteDecorator 具体装饰类：复杂向构件添加新的职责，每一个装饰类都定义了一些新的行为，可以调用抽象装饰的方法，也可以新增子装饰器方法</dd>
        <dt>优点</dt>
        <dd>扩展对象的功能非常灵活，不会增加太多子类</dd>
        <dd>可以对对象多次装饰，组合装饰类，创造不同的功能</dd>
        <dt>缺点</dt>
        <dd>比继承更容易出错，也难以查错，因为都是抽象构件类的子类；找不到功能出错的定义位置</dd>
    </dl>
    <h5>桥接模式</h5>
    <dl>
        <dl>使用说明</dl>
        <dd>重要程度4，难度3</dd>
        <dd>命名Bridge，xxx</dd>
        <dd></dd>
    </dl>
</body>
</html>